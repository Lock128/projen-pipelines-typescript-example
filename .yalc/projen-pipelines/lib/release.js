#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const path_1 = require("path");
const stdVer = require("standard-version");
function createManifest(outDir, namespace) {
    const projectInfo = JSON.parse((0, fs_1.readFileSync)((0, path_1.join)('package.json')).toString('utf-8'));
    const assemblyManifest = JSON.stringify({
        name: `${namespace}/${projectInfo.name}`,
        author: projectInfo.author,
        license: projectInfo.license,
        version: '0.0.0',
    }, null, 2);
    (0, fs_1.writeFileSync)((0, path_1.join)(outDir, 'package.json'), assemblyManifest, { encoding: 'utf-8' });
    const rcFile = (0, path_1.join)(outDir, '.npmrc');
    if ((0, fs_1.existsSync)(rcFile)) {
        (0, fs_1.rmSync)(rcFile, { force: true });
    }
    (0, fs_1.copyFileSync)('.npmrc', rcFile);
}
function bumpVersion() {
    void stdVer({
        packageFiles: [],
        bumpFiles: [],
        skip: {
            commit: true,
            changelog: true,
        },
        firstRelease: false,
        gitTagFallback: true,
        tagPrefix: '',
    }).then(console.log).catch(console.error);
}
switch (process.argv[2]) {
    case 'create-manifest':
        createManifest(process.argv[3], process.argv[4]);
        break;
    case 'bump':
        bumpVersion();
        break;
    default:
        console.log('Cannot find command: ' + process.argv[2]);
        break;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVsZWFzZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9yZWxlYXNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUVBLDJCQUFtRjtBQUNuRiwrQkFBNEI7QUFDNUIsMkNBQTJDO0FBRTNDLFNBQVMsY0FBYyxDQUFDLE1BQWMsRUFBRSxTQUFpQjtJQUN2RCxNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUEsaUJBQVksRUFBQyxJQUFBLFdBQUksRUFBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO0lBQ3JGLE1BQU0sZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQztRQUN0QyxJQUFJLEVBQUUsR0FBRyxTQUFTLElBQUksV0FBVyxDQUFDLElBQUksRUFBRTtRQUN4QyxNQUFNLEVBQUUsV0FBVyxDQUFDLE1BQU07UUFDMUIsT0FBTyxFQUFFLFdBQVcsQ0FBQyxPQUFPO1FBQzVCLE9BQU8sRUFBRSxPQUFPO0tBQ2pCLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ1osSUFBQSxrQkFBYSxFQUFDLElBQUEsV0FBSSxFQUFDLE1BQU0sRUFBRSxjQUFjLENBQUMsRUFBRSxnQkFBZ0IsRUFBRSxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDO0lBRXJGLE1BQU0sTUFBTSxHQUFHLElBQUEsV0FBSSxFQUFDLE1BQU0sRUFBRSxRQUFRLENBQUMsQ0FBQztJQUN0QyxJQUFJLElBQUEsZUFBVSxFQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUM7UUFDdkIsSUFBQSxXQUFNLEVBQUMsTUFBTSxFQUFFLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7SUFDbEMsQ0FBQztJQUNELElBQUEsaUJBQVksRUFBQyxRQUFRLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFDakMsQ0FBQztBQUVELFNBQVMsV0FBVztJQUNsQixLQUFLLE1BQU0sQ0FBQztRQUNWLFlBQVksRUFBRSxFQUFFO1FBQ2hCLFNBQVMsRUFBRSxFQUFFO1FBQ2IsSUFBSSxFQUFFO1lBQ0osTUFBTSxFQUFFLElBQUk7WUFDWixTQUFTLEVBQUUsSUFBSTtTQUNoQjtRQUNELFlBQVksRUFBRSxLQUFLO1FBQ25CLGNBQWMsRUFBRSxJQUFJO1FBQ3BCLFNBQVMsRUFBRSxFQUFFO0tBQ2QsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUM1QyxDQUFDO0FBRUQsUUFBUSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7SUFDeEIsS0FBSyxpQkFBaUI7UUFDcEIsY0FBYyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2pELE1BQU07SUFDUixLQUFLLE1BQU07UUFDVCxXQUFXLEVBQUUsQ0FBQztRQUNkLE1BQU07SUFDUjtRQUNFLE9BQU8sQ0FBQyxHQUFHLENBQUMsdUJBQXVCLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3ZELE1BQU07QUFDVixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiIyEvdXNyL2Jpbi9lbnYgbm9kZVxuXG5pbXBvcnQgeyBjb3B5RmlsZVN5bmMsIGV4aXN0c1N5bmMsIHJlYWRGaWxlU3luYywgd3JpdGVGaWxlU3luYywgcm1TeW5jIH0gZnJvbSAnZnMnO1xuaW1wb3J0IHsgam9pbiB9IGZyb20gJ3BhdGgnO1xuaW1wb3J0ICogYXMgc3RkVmVyIGZyb20gJ3N0YW5kYXJkLXZlcnNpb24nO1xuXG5mdW5jdGlvbiBjcmVhdGVNYW5pZmVzdChvdXREaXI6IHN0cmluZywgbmFtZXNwYWNlOiBzdHJpbmcpIHtcbiAgY29uc3QgcHJvamVjdEluZm8gPSBKU09OLnBhcnNlKHJlYWRGaWxlU3luYyhqb2luKCdwYWNrYWdlLmpzb24nKSkudG9TdHJpbmcoJ3V0Zi04JykpO1xuICBjb25zdCBhc3NlbWJseU1hbmlmZXN0ID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgIG5hbWU6IGAke25hbWVzcGFjZX0vJHtwcm9qZWN0SW5mby5uYW1lfWAsXG4gICAgYXV0aG9yOiBwcm9qZWN0SW5mby5hdXRob3IsXG4gICAgbGljZW5zZTogcHJvamVjdEluZm8ubGljZW5zZSxcbiAgICB2ZXJzaW9uOiAnMC4wLjAnLFxuICB9LCBudWxsLCAyKTtcbiAgd3JpdGVGaWxlU3luYyhqb2luKG91dERpciwgJ3BhY2thZ2UuanNvbicpLCBhc3NlbWJseU1hbmlmZXN0LCB7IGVuY29kaW5nOiAndXRmLTgnIH0pO1xuXG4gIGNvbnN0IHJjRmlsZSA9IGpvaW4ob3V0RGlyLCAnLm5wbXJjJyk7XG4gIGlmIChleGlzdHNTeW5jKHJjRmlsZSkpIHtcbiAgICBybVN5bmMocmNGaWxlLCB7IGZvcmNlOiB0cnVlIH0pO1xuICB9XG4gIGNvcHlGaWxlU3luYygnLm5wbXJjJywgcmNGaWxlKTtcbn1cblxuZnVuY3Rpb24gYnVtcFZlcnNpb24oKSB7XG4gIHZvaWQgc3RkVmVyKHtcbiAgICBwYWNrYWdlRmlsZXM6IFtdLFxuICAgIGJ1bXBGaWxlczogW10sXG4gICAgc2tpcDoge1xuICAgICAgY29tbWl0OiB0cnVlLFxuICAgICAgY2hhbmdlbG9nOiB0cnVlLFxuICAgIH0sXG4gICAgZmlyc3RSZWxlYXNlOiBmYWxzZSxcbiAgICBnaXRUYWdGYWxsYmFjazogdHJ1ZSxcbiAgICB0YWdQcmVmaXg6ICcnLFxuICB9KS50aGVuKGNvbnNvbGUubG9nKS5jYXRjaChjb25zb2xlLmVycm9yKTtcbn1cblxuc3dpdGNoIChwcm9jZXNzLmFyZ3ZbMl0pIHtcbiAgY2FzZSAnY3JlYXRlLW1hbmlmZXN0JzpcbiAgICBjcmVhdGVNYW5pZmVzdChwcm9jZXNzLmFyZ3ZbM10sIHByb2Nlc3MuYXJndls0XSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2J1bXAnOlxuICAgIGJ1bXBWZXJzaW9uKCk7XG4gICAgYnJlYWs7XG4gIGRlZmF1bHQ6XG4gICAgY29uc29sZS5sb2coJ0Nhbm5vdCBmaW5kIGNvbW1hbmQ6ICcgKyBwcm9jZXNzLmFyZ3ZbMl0pO1xuICAgIGJyZWFrO1xufVxuIl19